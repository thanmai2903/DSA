# [Surrounded Regions](https://leetcode.com/problems/surrounded-regions)

## Intuition:

1. start from borders if cell has a value of 'O'
2. mark it as visited => change to '#'
3. check all neighbors of it
4. base cond => i < 0 || j < 0 || i>=m || j >= n -> return;
5. Again taverse the board chceking

-   if cell = 'O' => not connected to border => surrouned region => change to 'X'
-   if cell = '#' => connected to border => not a surrouned region => change to 'O'

## Example

      -  Let's analyze when an 'O' cannot be flipped,
      -  if it has atleast one 'O' in it's adjacent, AND ultimately this chain of adjacent 'O's is connected to some 'O' which lies on boundary of board

      - consider these two cases for clarity :
      /*
        O's won't be flipped          O's will be flipped
        [X O X X X]                   [X X X X X]
        [X O O O X]                   [X O O O X]
        [X O X X X]                   [X O X X X]
        [X X X X X]                   [X X X X X]

      So we can conclude if a chain of adjacent O's is connected some O on boundary then they cannot be flipped

      */

## Code

Time/Space -> O(mn)/O(mn)

```cpp
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        int m = board.size(), n = board[0].size();
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if (board[i][j] == 'O' && (i == 0 || j == 0 || i == m - 1 || j == n - 1))
                    helper(board, i, j);
            }
        }
        //if cell = 'O' => not connected to border => surrouned region => change to 'X'
        //if cell = '#' =>  connected to border => not a surrouned region => change to 'O'
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if (board[i][j] == 'O')
                    board[i][j] = 'X';
                else if (board[i][j] == '#')
                    board[i][j] = 'O';
            }
        }
    }

    void helper(vector<vector<char>>& board, int i, int j) {
        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size()) {
            return;
        }

        if(board[i][j] == 'O') {
            board[i][j] = '#';
            helper(board, i + 1, j);
            helper(board, i, j - 1);
            helper(board, i, j + 1);
            helper(board, i - 1, j);
        }
    }
};
```

#### Method 2

TIme/Space -> O(mn)/O(mn)

```cpp
class Solution {
public:
    void DFS(vector<vector<char>>& board, int i, int j, int m, int n) {
        if(i<0 or j<0 or i>=m or j>=n or board[i][j] != 'O') return;
        board[i][j] = '#';
        DFS(board, i-1, j, m, n);
        DFS(board, i+1, j, m, n);
        DFS(board, i, j-1, m, n);
        DFS(board, i, j+1, m, n);
    }

    void solve(vector<vector<char>>& board) {

     int m = board.size();

      if(m == 0) return;

     int n = board[0].size();

     //Moving over first and last column
     for(int i=0; i<m; i++) {
         if(board[i][0] == 'O')
             DFS(board, i, 0, m, n);
         if(board[i][n-1] == 'O')
             DFS(board, i, n-1, m, n);
     }


     //Moving over first and last row
     for(int j=0; j<n; j++) {
         if(board[0][j] == 'O')
             DFS(board, 0, j, m, n);
         if(board[m-1][j] == 'O')
             DFS(board, m-1, j, m, n);
     }

     for(int i=0; i<m; i++)
         for(int j=0; j<n; j++)
         {
             if(board[i][j] == 'O')
                 board[i][j] = 'X';
             if(board[i][j] == '#')
                 board[i][j] = 'O';
         }
    }
};
```
