# Stack Implementation in C++

## 1. Stack Implementation Using Arrays

### Creation

A stack can be implemented using a static array with a fixed size. Here's how you can define and initialize it:

```cpp
#include <iostream>
#define MAX 1000

class Stack {
    int top;
public:
    int arr[MAX]; // Maximum size of Stack

    Stack() { top = -1; } // Constructor

    bool push(int x);
    int pop();
    int peek();
    bool isEmpty();
};

// Function to add an item to stack. It increases top by 1
bool Stack::push(int x) {
    if (top >= (MAX - 1)) {
        std::cout << "Stack Overflow";
        return false;
    } else {
        arr[++top] = x;
        std::cout << x << " pushed into stack\n";
        return true;
    }
}

// Function to remove an item from stack. It decreases top by 1
int Stack::pop() {
    if (top < 0) {
        std::cout << "Stack Underflow";
        return 0;
    } else {
        int x = arr[top--];
        return x;
    }
}

// Function to get the top item from stack
int Stack::peek() {
    if (top < 0) {
        std::cout << "Stack is Empty";
        return 0;
    } else {
        int x = arr[top];
        return x;
    }
}

// Function to check if the stack is empty
bool Stack::isEmpty() {
    return (top < 0);
}
```

### Traversal

To traverse the stack and print its elements:

```cpp
void traverse(Stack s) {
    if (s.isEmpty()) {
        std::cout << "Stack is empty\n";
        return;
    }
    std::cout << "Stack elements are:\n";
    for (int i = s.top; i >= 0; i--) {
        std::cout << s.arr[i] << " ";
    }
    std::cout << "\n";
}
```

### Example Usage

```cpp
int main() {
    class Stack s;
    s.push(10);
    s.push(20);
    s.push(30);
    std::cout << s.pop() << " Popped from stack\n";
    traverse(s);
    return 0;
}
```

## 2. Stack Implementation Using Linked List

### Node Definition

First, we define a Node structure:

```cpp
#include <iostream>

class StackNode {
public:
    int data;
    StackNode* next;
};

StackNode* newNode(int data) {
    StackNode* stackNode = new StackNode();
    stackNode->data = data;
    stackNode->next = nullptr;
    return stackNode;
}
```

### Stack Operations

We define the stack operations:

```cpp
class Stack {
    StackNode* root;
public:
    Stack() { root = nullptr; }

    bool isEmpty();
    void push(int data);
    int pop();
    int peek();
};

// Function to check if the stack is empty
bool Stack::isEmpty() {
    return !root;
}

// Function to add an item to stack
void Stack::push(int data) {
    StackNode* stackNode = newNode(data);
    stackNode->next = root;
    root = stackNode;
    std::cout << data << " pushed into stack\n";
}

// Function to remove an item from stack
int Stack::pop() {
    if (isEmpty()) {
        std::cout << "Stack Underflow\n";
        return 0;
    } else {
        StackNode* temp = root;
        root = root->next;
        int popped = temp->data;
        delete temp;
        return popped;
    }
}

// Function to get the top item from stack
int Stack::peek() {
    if (isEmpty()) {
        std::cout << "Stack is Empty\n";
        return 0;
    } else {
        return root->data;
    }
}
```

### Traversal

To traverse the stack and print its elements:

```cpp
void traverse(Stack s) {
    StackNode* temp = s.root;
    if (!temp) {
        std::cout << "Stack is empty\n";
        return;
    }
    std::cout << "Stack elements are:\n";
    while (temp != nullptr) {
        std::cout << temp->data << " ";
        temp = temp->next;
    }
    std::cout << "\n";
}
```

### Example Usage

```cpp
int main() {
    Stack s;
    s.push(10);
    s.push(20);
    s.push(30);
    std::cout << s.pop() << " Popped from stack\n";
    traverse(s);
    return 0;
}
```

# Advanced Stack Implementations in C++

## 1. Reversing a Stack

### Using an Auxiliary Stack

```cpp
void reverseStack(Stack& s) {
    Stack aux;
    while (!s.isEmpty()) {
        aux.push(s.pop());
    }
    while (!aux.isEmpty()) {
        s.push(aux.pop());
    }
}
```

## 2. Implementing Two Stacks in a Single Array

### Creation

```cpp
#include <iostream>
#define MAX 1000

class TwoStacks {
    int* arr;
    int top1, top2;
public:
    TwoStacks(int n) {
        arr = new int[n];
        top1 = -1;
        top2 = n;
    }

    void push1(int x);
    void push2(int x);
    int pop1();
    int pop2();
};

// Function to push an element x to stack1
void TwoStacks::push1(int x) {
    if (top1 < top2 - 1) {
        arr[++top1] = x;
    } else {
        std::cout << "Stack Overflow\n";
    }
}

// Function to push an element x to stack2
void TwoStacks::push2(int x) {
    if (top1 < top2 - 1) {
        arr[--top2] = x;
    } else {
        std::cout << "Stack Overflow\n";
    }
}

// Function to pop an element from stack1
int TwoStacks::pop1() {
    if (top1 >= 0) {
        int x = arr[top1--];
        return x;
    } else {
        std::cout << "Stack Underflow\n";
        return 0;
    }
}

// Function to pop an element from stack2
int TwoStacks::pop2() {
    if (top2 < MAX) {
        int x = arr[top2++];
        return x;
    } else {
        std::cout << "Stack Underflow\n";
        return 0;
    }
}
```

## 3. Checking for Balanced Parentheses Using a Stack

```cpp
#include <iostream>
#include <stack>
using namespace std;

bool isBalanced(string expr) {
    stack<char> s;
    char x;

    for (int i = 0; i < expr.length(); i++) {
        if (expr[i] == '(' || expr[i] == '[' || expr[i] == '{') {
            s.push(expr[i]);
            continue;
        }

        if (s.empty())
            return false;

        switch (expr[i]) {
        case ')':
            x = s.top();
            s.pop();
            if (x == '{' || x == '[')
                return false;
            break;

        case '}':
            x = s.top();
            s.pop();
            if (x == '(' || x == '[')
                return false;
            break;

        case ']':
            x = s.top();
            s.pop();
            if (x == '(' || x == '{')
                return false;
            break;
        }
    }

    return (s.empty());
}
```

### Example Usage

```cpp
int main() {
    string expr = "{()}[]";
    if (isBalanced(expr))
        cout << "Balanced";
    else
        cout << "Not Balanced";
    return 0;
}
```

## 4. Infix to Postfix Conversion Using Stack

```cpp
#include <iostream>
#include <stack>
using namespace std;

// Function to return precedence of operators
int precedence(char c) {
    if (c == '^')
        return 3;
    else if (c == '*' || c == '/')
        return 2;
    else if (c == '+' || c == '-')
        return 1;
    else
        return -1;
}

// Function to convert infix expression to postfix
void infixToPostfix(string s) {
    stack<char> st;
    st.push('N');
    int l = s.length();
    string ns;
    for (int i = 0; i < l; i++) {
        // If the scanned character is an operand, add it to output string.
        if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z') || (s[i] >= '0' && s[i] <= '9'))
            ns += s[i];
        // If the scanned character is an ‘(‘, push it to the stack.
        else if (s[i] == '(')
            st.push('(');
        // If the scanned character is an ‘)’, pop and output from the stack
        // until an ‘(‘ is encountered.
        else if (s[i] == ')') {
            while (st.top() != 'N' && st.top() != '(') {
                char c = st.top();
                st.pop();
                ns += c;
            }
            if (st.top() == '(') {
                char c = st.top();
                st.pop();
            }
        }
        // If an operator is scanned
        else {
            while (st.top() != 'N' && precedence(s[i]) <= precedence(st.top())) {
                char c = st.top();
                st.pop();
                ns += c;
            }
            st.push(s[i]);
        }
    }
    // Pop all the operators from the stack
    while (st.top() != 'N') {
        char c = st.top();
        st.pop();
        ns += c;
    }
    cout << ns << endl;
}
```

### Example Usage

```cpp
int main() {
    string exp = "a+b*(c^d-e)^(f+g*h)-i";
    infixToPostfix(exp);
    return 0;
}
```

## 5. Implementing a Special Stack with GetMin Function

```cpp
#include <iostream>
#include <stack>
using namespace std;

class SpecialStack {
    stack<int> s;
    int minEle;

public:
    void push(int x) {
        if (s.empty()) {
            s.push(x);
            minEle = x;
            cout << "Number inserted: " << x << endl;
            return;
        }
        if (x < minEle) {
            s.push(2 * x - minEle);
            minEle = x;
        } else {
            s.push(x);
        }
        cout << "Number inserted: " << x << endl;
    }

    void pop() {
        if (s.empty()) {
            cout << "Stack is empty\n";
            return;
        }
        int t = s.top();
        s.pop();
        if (t < minEle) {
            cout << "Popped element: " << minEle << endl;
            minEle = 2 * minEle - t;
        } else {
            cout << "Popped element: " << t << endl;
        }
    }

    int getMin() {
        if (s.empty()) {
            cout << "Stack is empty\n";
            return -1;
        } else {
            return minEle;
        }
    }
};
```

### Example Usage

```cpp
int main() {
    SpecialStack s;
    s.push(3);
    s.push(5);
    cout << "Minimum element: " << s.getMin() << endl;
    s.push(2);
    s.push(1);
    cout << "Minimum element: " << s.getMin() << endl;
    s.pop();
    cout << "Minimum element: " << s.getMin() << endl;
    s.pop();
    cout << "Minimum element: " << s.getMin() << endl;
    return 0;
}
```

## Infix to postfix

```cpp
#include <iostream>
#include <stack>
#include <string>

using namespace std;

// Function to return precedence of operators
int precedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    if (op == '^') return 3;
    return 0;
}

// Function to check if the character is an operator
bool isOperator(char c) {
    return (!isalpha(c) && !isdigit(c));
}

// Function to perform infix to postfix conversion
string infixToPostfix(string infix) {
    stack<char> s;
    string postfix;

    for (char &c : infix) {
        // If the character is an operand, add it to the postfix expression
        if (isalnum(c)) {
            postfix += c;
        }
        // If the character is '(', push it onto the stack
        else if (c == '(') {
            s.push(c);
        }
        // If the character is ')', pop and output from the stack until '(' is found
        else if (c == ')') {
            while (!s.empty() && s.top() != '(') {
                postfix += s.top();
                s.pop();
            }
            s.pop(); // remove '(' from stack
        }
        // If the character is an operator
        else {
            while (!s.empty() && precedence(s.top()) >= precedence(c)) {
                postfix += s.top();
                s.pop();
            }
            s.push(c);
        }
    }

    // Pop all the operators from the stack
    while (!s.empty()) {
        postfix += s.top();
        s.pop();
    }

    return postfix;
}

int main() {
    string infix = "a+b*(c^d-e)^(f+g*h)-i";
    cout << "Infix Expression: " << infix << endl;
    cout << "Postfix Expression: " << infixToPostfix(infix) << endl;
    return 0;
}
```

## Infix to Prefix

```cpp
#include <iostream>
#include <stack>
#include <algorithm>
#include <string>

using namespace std;

// Function to return precedence of operators
int precedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    if (op == '^') return 3;
    return 0;
}

// Function to check if the character is an operator
bool isOperator(char c) {
    return (!isalpha(c) && !isdigit(c));
}

// Function to perform infix to postfix conversion
string infixToPostfix(string infix) {
    stack<char> s;
    string postfix;

    for (char &c : infix) {
        // If the character is an operand, add it to the postfix expression
        if (isalnum(c)) {
            postfix += c;
        }
        // If the character is '(', push it onto the stack
        else if (c == '(') {
            s.push(c);
        }
        // If the character is ')', pop and output from the stack until '(' is found
        else if (c == ')') {
            while (!s.empty() && s.top() != '(') {
                postfix += s.top();
                s.pop();
            }
            s.pop(); // remove '(' from stack
        }
        // If the character is an operator
        else {
            while (!s.empty() && precedence(s.top()) > precedence(c)) {
                postfix += s.top();
                s.pop();
            }
            s.push(c);
        }
    }

    // Pop all the operators from the stack
    while (!s.empty()) {
        postfix += s.top();
        s.pop();
    }

    return postfix;
}

// Function to reverse a string and swap parentheses
string reverseAndSwapParentheses(string expr) {
    reverse(expr.begin(), expr.end());
    for (char &c : expr) {
        if (c == '(') c = ')';
        else if (c == ')') c = '(';
    }
    return expr;
}

// Function to perform infix to prefix conversion
string infixToPrefix(string infix) {
    // Step 1: Reverse and swap parentheses
    string reversedInfix = reverseAndSwapParentheses(infix);
    // Step 2: Get postfix of the reversed and swapped expression
    string postfix = infixToPostfix(reversedInfix);
    // Step 3: Reverse the postfix expression to get the prefix expression
    reverse(postfix.begin(), postfix.end());
    return postfix;
}

int main() {
    string infix = "a+b*(c^d-e)^(f+g*h)-i";
    cout << "Infix Expression: " << infix << endl;
    cout << "Prefix Expression: " << infixToPrefix(infix) << endl;
    return 0;
}
```

## Postfix to Infix

```cpp
#include <iostream>
#include <stack>
#include <string>

using namespace std;

// Function to check if the character is an operator
bool isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '^');
}

// Function to convert postfix to infix
string postfixToInfix(string postfix) {
    stack<string> s;

    for (char &c : postfix) {
        // If the character is an operand, push it onto the stack
        if (isalnum(c)) {
            s.push(string(1, c));
        }
        // If the character is an operator
        else if (isOperator(c)) {
            // Pop two operands from the stack
            string op2 = s.top(); s.pop();
            string op1 = s.top(); s.pop();

            // Form a new string with the operator between the operands
            string expr = "(" + op1 + c + op2 + ")";

            // Push the resulting string back onto the stack
            s.push(expr);
        }
    }

    // The final element in the stack is the infix expression
    return s.top();
}

int main() {
    string postfix = "abcd^e-fgh*+^*+i-";
    cout << "Postfix Expression: " << postfix << endl;
    cout << "Infix Expression: " << postfixToInfix(postfix) << endl;
    return 0;
}
```

## Prefix to Infix

```cpp
#include <iostream>
#include <stack>
#include <string>

using namespace std;

// Function to check if the character is an operator
bool isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '^');
}

// Function to convert prefix to infix
string prefixToInfix(string prefix) {
    stack<string> s;
    int length = prefix.size();

    // Scan the prefix expression from right to left
    for (int i = length - 1; i >= 0; i--) {
        // If the character is an operand, push it onto the stack
        if (isalnum(prefix[i])) {
            s.push(string(1, prefix[i]));
        }
        // If the character is an operator
        else if (isOperator(prefix[i])) {
            // Pop two operands from the stack
            string op1 = s.top(); s.pop();
            string op2 = s.top(); s.pop();

            // Form a new string with the operator between the operands
            string expr = "(" + op1 + prefix[i] + op2 + ")";

            // Push the resulting string back onto the stack
            s.push(expr);
        }
    }

    // The final element in the stack is the infix expression
    return s.top();
}

int main() {
    string prefix = "*-A/BC-/AKL";
    cout << "Prefix Expression: " << prefix << endl;
    cout << "Infix Expression: " << prefixToInfix(prefix) << endl;
    return 0;
}
```

## Postfix to Prefix

```cpp
#include <iostream>
#include <stack>
#include <string>

using namespace std;

// Function to check if the character is an operator
bool isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '^');
}

// Function to convert postfix to prefix
string postfixToPrefix(string postfix) {
    stack<string> s;

    for (char &c : postfix) {
        // If the character is an operand, push it onto the stack
        if (isalnum(c)) {
            s.push(string(1, c));
        }
        // If the character is an operator
        else if (isOperator(c)) {
            // Pop two operands from the stack
            string op2 = s.top(); s.pop();
            string op1 = s.top(); s.pop();

            // Form a new string with the operator followed by the operands
            string expr = c + op1 + op2;

            // Push the resulting string back onto the stack
            s.push(expr);
        }
    }

    // The final element in the stack is the prefix expression
    return s.top();
}

int main() {
    string postfix = "AB+CD-*";
    cout << "Postfix Expression: " << postfix << endl;
    cout << "Prefix Expression: " << postfixToPrefix(postfix) << endl;
    return 0;
}
```

## Prefix to postfix

```cpp
#include <iostream>
#include <stack>
#include <string>

using namespace std;

// Function to check if the character is an operator
bool isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '^');
}

// Function to convert prefix to postfix
string prefixToPostfix(string prefix) {
    stack<string> s;
    int length = prefix.size();

    // Scan the prefix expression from right to left
    for (int i = length - 1; i >= 0; i--) {
        // If the character is an operand, push it onto the stack
        if (isalnum(prefix[i])) {
            s.push(string(1, prefix[i]));
        }
        // If the character is an operator
        else if (isOperator(prefix[i])) {
            // Pop two operands from the stack
            string op1 = s.top(); s.pop();
            string op2 = s.top(); s.pop();

            // Form a new string with the operands followed by the operator
            string expr = op1 + op2 + prefix[i];

            // Push the resulting string back onto the stack
            s.push(expr);
        }
    }

    // The final element in the stack is the postfix expression
    return s.top();
}

int main() {
    string prefix = "*-A/BC-/AKL";
    cout << "Prefix Expression: " << prefix << endl;
    cout << "Postfix Expression: " << prefixToPostfix(prefix) << endl;
    return 0;
}
```

# Summary in a Table

Here's a summary of various algorithms for different conversions along with the key steps:

| **Algorithm**         | **Steps**                                                                                                                                              | **Mnemonic/Trick**                                           |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------ |
| **Infix to Postfix**  | 1. Scan left to right<br>2. Use stack for operators<br>3. Push operands to output<br>4. Handle parentheses<br>5. Pop all remaining operators to output | _Operators Stack_, _Operands Output_, _Parentheses Handling_ |
| **Infix to Prefix**   | 1. Reverse infix<br>2. Swap parentheses<br>3. Convert to postfix<br>4. Reverse postfix                                                                 | _Reverse, Swap, Convert, Reverse_                            |
| **Postfix to Infix**  | 1. Scan left to right<br>2. Use stack for operands<br>3. Push operators to form sub-expressions                                                        | _Operands Stack_, _Sub-expressions with Operators_           |
| **Prefix to Infix**   | 1. Scan right to left<br>2. Use stack for operands<br>3. Push operators to form sub-expressions                                                        | _Operands Stack_, _Sub-expressions with Operators_           |
| **Postfix to Prefix** | 1. Scan left to right<br>2. Use stack for operands<br>3. Push operators to form prefix sub-expressions                                                 | _Operands Stack_, _Prefix Sub-expressions with Operators_    |
| **Prefix to Postfix** | 1. Scan right to left<br>2. Use stack for operands<br>3. Push operators to form postfix sub-expressions                                                | _Operands Stack_, _Postfix Sub-expressions with Operators_   |

# Detailed Explanation with Mnemonics

1. **Infix to Postfix:**

    - **Mnemonic:** _Operators Stack, Operands Output, Parentheses Handling_
    - **Key Steps:**
        1. Scan the expression from left to right.
        2. Use a stack to keep track of operators.
        3. Push operands directly to the output.
        4. Handle opening and closing parentheses.
        5. Pop all remaining operators to the output.

2. **Infix to Prefix:**

    - **Mnemonic:** _Reverse, Swap, Convert, Reverse_
    - **Key Steps:**
        1. Reverse the infix expression.
        2. Swap opening and closing parentheses.
        3. Convert the modified expression to postfix.
        4. Reverse the postfix expression to get the prefix.

3. **Postfix to Infix:**

    - **Mnemonic:** _Operands Stack, Sub-expressions with Operators_
    - **Key Steps:**
        1. Scan the expression from left to right.
        2. Use a stack to keep track of operands.
        3. When encountering an operator, pop the top two operands, form a sub-expression, and push it back.

4. **Prefix to Infix:**

    - **Mnemonic:** _Operands Stack, Sub-expressions with Operators_
    - **Key Steps:**
        1. Scan the expression from right to left.
        2. Use a stack to keep track of operands.
        3. When encountering an operator, pop the top two operands, form a sub-expression, and push it back.

5. **Postfix to Prefix:**

    - **Mnemonic:** _Operands Stack, Prefix Sub-expressions with Operators_
    - **Key Steps:**
        1. Scan the expression from left to right.
        2. Use a stack to keep track of operands.
        3. When encountering an operator, pop the top two operands, form a prefix sub-expression, and push it back.

6. **Prefix to Postfix:**
    - **Mnemonic:** _Operands Stack, Postfix Sub-expressions with Operators_
    - **Key Steps:**
        1. Scan the expression from right to left.
        2. Use a stack to keep track of operands.
        3. When encountering an operator, pop the top two operands, form a postfix sub-expression, and push it back.
