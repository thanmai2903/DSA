# Stack Implementation in C++

## 1. Stack Implementation Using Arrays

### Creation

A stack can be implemented using a static array with a fixed size. Here's how you can define and initialize it:

```cpp
#include <iostream>
#define MAX 1000

class Stack {
    int top;
public:
    int arr[MAX]; // Maximum size of Stack

    Stack() { top = -1; } // Constructor

    bool push(int x);
    int pop();
    int peek();
    bool isEmpty();
};

// Function to add an item to stack. It increases top by 1
bool Stack::push(int x) {
    if (top >= (MAX - 1)) {
        std::cout << "Stack Overflow";
        return false;
    } else {
        arr[++top] = x;
        std::cout << x << " pushed into stack\n";
        return true;
    }
}

// Function to remove an item from stack. It decreases top by 1
int Stack::pop() {
    if (top < 0) {
        std::cout << "Stack Underflow";
        return 0;
    } else {
        int x = arr[top--];
        return x;
    }
}

// Function to get the top item from stack
int Stack::peek() {
    if (top < 0) {
        std::cout << "Stack is Empty";
        return 0;
    } else {
        int x = arr[top];
        return x;
    }
}

// Function to check if the stack is empty
bool Stack::isEmpty() {
    return (top < 0);
}
```

### Traversal

To traverse the stack and print its elements:

```cpp
void traverse(Stack s) {
    if (s.isEmpty()) {
        std::cout << "Stack is empty\n";
        return;
    }
    std::cout << "Stack elements are:\n";
    for (int i = s.top; i >= 0; i--) {
        std::cout << s.arr[i] << " ";
    }
    std::cout << "\n";
}
```

### Example Usage

```cpp
int main() {
    class Stack s;
    s.push(10);
    s.push(20);
    s.push(30);
    std::cout << s.pop() << " Popped from stack\n";
    traverse(s);
    return 0;
}
```

## 2. Stack Implementation Using Linked List

### Node Definition

First, we define a Node structure:

```cpp
#include <iostream>

class StackNode {
public:
    int data;
    StackNode* next;
};

StackNode* newNode(int data) {
    StackNode* stackNode = new StackNode();
    stackNode->data = data;
    stackNode->next = nullptr;
    return stackNode;
}
```

### Stack Operations

We define the stack operations:

```cpp
class Stack {
    StackNode* root;
public:
    Stack() { root = nullptr; }

    bool isEmpty();
    void push(int data);
    int pop();
    int peek();
};

// Function to check if the stack is empty
bool Stack::isEmpty() {
    return !root;
}

// Function to add an item to stack
void Stack::push(int data) {
    StackNode* stackNode = newNode(data);
    stackNode->next = root;
    root = stackNode;
    std::cout << data << " pushed into stack\n";
}

// Function to remove an item from stack
int Stack::pop() {
    if (isEmpty()) {
        std::cout << "Stack Underflow\n";
        return 0;
    } else {
        StackNode* temp = root;
        root = root->next;
        int popped = temp->data;
        delete temp;
        return popped;
    }
}

// Function to get the top item from stack
int Stack::peek() {
    if (isEmpty()) {
        std::cout << "Stack is Empty\n";
        return 0;
    } else {
        return root->data;
    }
}
```

### Traversal

To traverse the stack and print its elements:

```cpp
void traverse(Stack s) {
    StackNode* temp = s.root;
    if (!temp) {
        std::cout << "Stack is empty\n";
        return;
    }
    std::cout << "Stack elements are:\n";
    while (temp != nullptr) {
        std::cout << temp->data << " ";
        temp = temp->next;
    }
    std::cout << "\n";
}
```

### Example Usage

```cpp
int main() {
    Stack s;
    s.push(10);
    s.push(20);
    s.push(30);
    std::cout << s.pop() << " Popped from stack\n";
    traverse(s);
    return 0;
}
```

# Advanced Stack Implementations in C++

## 1. Reversing a Stack

### Using an Auxiliary Stack

```cpp
void reverseStack(Stack& s) {
    Stack aux;
    while (!s.isEmpty()) {
        aux.push(s.pop());
    }
    while (!aux.isEmpty()) {
        s.push(aux.pop());
    }
}
```

## 2. Implementing Two Stacks in a Single Array

### Creation

```cpp
#include <iostream>
#define MAX 1000

class TwoStacks {
    int* arr;
    int top1, top2;
public:
    TwoStacks(int n) {
        arr = new int[n];
        top1 = -1;
        top2 = n;
    }

    void push1(int x);
    void push2(int x);
    int pop1();
    int pop2();
};

// Function to push an element x to stack1
void TwoStacks::push1(int x) {
    if (top1 < top2 - 1) {
        arr[++top1] = x;
    } else {
        std::cout << "Stack Overflow\n";
    }
}

// Function to push an element x to stack2
void TwoStacks::push2(int x) {
    if (top1 < top2 - 1) {
        arr[--top2] = x;
    } else {
        std::cout << "Stack Overflow\n";
    }
}

// Function to pop an element from stack1
int TwoStacks::pop1() {
    if (top1 >= 0) {
        int x = arr[top1--];
        return x;
    } else {
        std::cout << "Stack Underflow\n";
        return 0;
    }
}

// Function to pop an element from stack2
int TwoStacks::pop2() {
    if (top2 < MAX) {
        int x = arr[top2++];
        return x;
    } else {
        std::cout << "Stack Underflow\n";
        return 0;
    }
}
```

## 3. Checking for Balanced Parentheses Using a Stack

```cpp
#include <iostream>
#include <stack>
using namespace std;

bool isBalanced(string expr) {
    stack<char> s;
    char x;

    for (int i = 0; i < expr.length(); i++) {
        if (expr[i] == '(' || expr[i] == '[' || expr[i] == '{') {
            s.push(expr[i]);
            continue;
        }

        if (s.empty())
            return false;

        switch (expr[i]) {
        case ')':
            x = s.top();
            s.pop();
            if (x == '{' || x == '[')
                return false;
            break;

        case '}':
            x = s.top();
            s.pop();
            if (x == '(' || x == '[')
                return false;
            break;

        case ']':
            x = s.top();
            s.pop();
            if (x == '(' || x == '{')
                return false;
            break;
        }
    }

    return (s.empty());
}
```

### Example Usage

```cpp
int main() {
    string expr = "{()}[]";
    if (isBalanced(expr))
        cout << "Balanced";
    else
        cout << "Not Balanced";
    return 0;
}
```

## 4. Infix to Postfix Conversion Using Stack

```cpp
#include <iostream>
#include <stack>
using namespace std;

// Function to return precedence of operators
int precedence(char c) {
    if (c == '^')
        return 3;
    else if (c == '*' || c == '/')
        return 2;
    else if (c == '+' || c == '-')
        return 1;
    else
        return -1;
}

// Function to convert infix expression to postfix
void infixToPostfix(string s) {
    stack<char> st;
    st.push('N');
    int l = s.length();
    string ns;
    for (int i = 0; i < l; i++) {
        // If the scanned character is an operand, add it to output string.
        if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z') || (s[i] >= '0' && s[i] <= '9'))
            ns += s[i];
        // If the scanned character is an ‘(‘, push it to the stack.
        else if (s[i] == '(')
            st.push('(');
        // If the scanned character is an ‘)’, pop and output from the stack
        // until an ‘(‘ is encountered.
        else if (s[i] == ')') {
            while (st.top() != 'N' && st.top() != '(') {
                char c = st.top();
                st.pop();
                ns += c;
            }
            if (st.top() == '(') {
                char c = st.top();
                st.pop();
            }
        }
        // If an operator is scanned
        else {
            while (st.top() != 'N' && precedence(s[i]) <= precedence(st.top())) {
                char c = st.top();
                st.pop();
                ns += c;
            }
            st.push(s[i]);
        }
    }
    // Pop all the operators from the stack
    while (st.top() != 'N') {
        char c = st.top();
        st.pop();
        ns += c;
    }
    cout << ns << endl;
}
```

### Example Usage

```cpp
int main() {
    string exp = "a+b*(c^d-e)^(f+g*h)-i";
    infixToPostfix(exp);
    return 0;
}
```

## 5. Implementing a Special Stack with GetMin Function

```cpp
#include <iostream>
#include <stack>
using namespace std;

class SpecialStack {
    stack<int> s;
    int minEle;

public:
    void push(int x) {
        if (s.empty()) {
            s.push(x);
            minEle = x;
            cout << "Number inserted: " << x << endl;
            return;
        }
        if (x < minEle) {
            s.push(2 * x - minEle);
            minEle = x;
        } else {
            s.push(x);
        }
        cout << "Number inserted: " << x << endl;
    }

    void pop() {
        if (s.empty()) {
            cout << "Stack is empty\n";
            return;
        }
        int t = s.top();
        s.pop();
        if (t < minEle) {
            cout << "Popped element: " << minEle << endl;
            minEle = 2 * minEle - t;
        } else {
            cout << "Popped element: " << t << endl;
        }
    }

    int getMin() {
        if (s.empty()) {
            cout << "Stack is empty\n";
            return -1;
        } else {
            return minEle;
        }
    }
};
```

### Example Usage

```cpp
int main() {
    SpecialStack s;
    s.push(3);
    s.push(5);
    cout << "Minimum element: " << s.getMin() << endl;
    s.push(2);
    s.push(1);
    cout << "Minimum element: " << s.getMin() << endl;
    s.pop();
    cout << "Minimum element: " << s.getMin() << endl;
    s.pop();
    cout << "Minimum element: " << s.getMin() << endl;
    return 0;
}
```
