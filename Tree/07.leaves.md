1. [Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves/)

## M-1. DFS

```cpp

class Solution {
public:
    int res = 0;
    int sumOfLeftLeaves(TreeNode* root) {
        helper(root);
        return res;
    }
    void helper(TreeNode* root){
        if(!root) return ;
        if(root->left && !root->left->left && !root->left->right) res += root->left->val;
        helper(root->left);
        helper(root->right);
    }
};
```

## M-2. BFS

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        queue<pair<TreeNode*, bool>> q;
        q.push({root, false});
        int ans = 0;
        while(q.size()) {
            auto [cur, isLeft] = q.front(); q.pop();
            if(!cur -> left && !cur -> right && isLeft)
                ans += cur -> val;
            if(cur -> right) q.push({cur -> right, false});
            if(cur -> left) q.push({cur -> left, true});
        }
        return ans;
    }
};
```

2. [Leaf-Similar Trees](https://leetcode.com/problems/leaf-similar-trees/solutions/)

```cpp
class Solution {
public:
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {
        vector<int>one, two;
        helper(root1, one);
        helper(root2, two);
        return one == two;
    }
    void helper(TreeNode* root, vector<int>& v){
        if(!root){
            return;
        }
        if(!root->left && !root->right){
            v.push_back(root->val);
        }
        helper(root->left, v);
        helper(root->right, v);
    }
};
```

3. [Deepest Leaves Sum](https://leetcode.com/problems/deepest-leaves-sum/)

## M-1. BFS

```cpp
class Solution {
public:
    int deepestLeavesSum(TreeNode* root){
        queue<TreeNode* >q;
        q.push(root);
        int sum;
        while(!q.empty()){
            sum = 0;
            int levelSize = q.size();
            for(int i=0; i < levelSize; ++i){
                TreeNode* p = q.front();
                sum += p->val;
                q.pop();
                if(p->left) q.push(p->left);
                if(p->right) q.push(p->right);
            }
        }
        return sum;
    }
};
```

## M-2. DFS

```cpp
int deepest = 0, sum = 0;
int deepestLeavesSum(TreeNode* root, int depth = 0) {
	if(!root) return 0;  // current node is NULL - just return.
	if(!root -> left && !root -> right) // if current is a leaf node
		if(depth == deepest) sum += root -> val;  // if depth is exactly equal to deepest, add to sum
		else if(depth > deepest) sum = root -> val, deepest = depth; // found a more deeper leaf node, reset sum and update deepest
	deepestLeavesSum(root -> left, depth + 1);   // recurse for the left,
	deepestLeavesSum(root -> right, depth + 1);  // and the right node of the current node
	return sum; // finally return the sum accumulated till now which will be sum of value of deepest leaves
}
```

**NOTE**

```
Q. DFS vs BFS. Which would be more efficient ? When would you prefer one over the other ?
Ans : If you were to get such a problem in interview, it's very likely that the interviewer would proceed to ask a follow-up question such as this one. The DFS vs BFS is a vast topic of discussion. But one thing that's for sure (and helpful to know) is none is always better than the other. You would need to have an idea of probable structure of Tree/Graph that would be given as input (and ofcourse what you need to find depending on the question ) to make a better decision about which approach to prefer.

A DFS is easy to implement and generally has advantage of being space-efficient, especially in a balanced / almost balanced Tree and the space required would be O(h) (where h is the height of the tree) while we would require O(2^h) space complexity for BFS traversal which could consume huge amount of memory when tree is balanced & for h is larger.

On the other hand, BFS would perform well if you don't need to search the entire depth of the tree or if the tree is skewed and there are only few branches going very deep. In worst case, the height of a tree h could be equal to n and if there are huge number of nodes, DFS would consume huge amounts of memory & may lead to stackoverflow.

In this question, the DFS performed marginally better giving better space efficiency than BFS. Again, this depends on the structure of trees used in the test cases.
```

4. [Delete Leaves With a Given Value](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/)

## DFS

```cpp
class Solution {
public:
    TreeNode* removeLeafNodes(TreeNode* root, int target) {
        if (root->left) root->left = removeLeafNodes(root->left, target);
        if (root->right) root->right = removeLeafNodes(root->right, target);
        if(root->left == root->right && root->val == target)
            return nullptr;
        return root;
    }
};
```
