# Radial Traversal

-   In such type of problem we given target node [any node in tree also possibly root] and travel level by level from that node to finding ans.

**Template**

-   Build parent and child relation map
-   Do level order traversal or DFS

```cpp
// Building parent and child relation map
unordered_map<TreeNode*, TreeNode*> parent;
void dfs(TreeNode* root, TreeNode* par) {
	if(!root) return;
	parent[root] = par;
	dfs(root -> left, root);
	dfs(root -> right, root);
}
// Do level order traversal
void levelOrderTraversal(TreeNode* target, int data) {
	queue<TreeNode*> q;
	q.push(target);

	vector<bool> seen(N);
	seen[target -> val] = true;

	while(!q.empty()) {
		for(int sz = q.size(); sz > 0; sz--) {
			TreeNode* cur = q.front(); q.pop();
			// push left child
			if(cur -> left && !seen[cur -> left -> val]) {
				seen[cur -> left -> val] = true;
				q.push(cur -> left);
			}
			// push right child
			if(cur -> right && !seen[cur -> right -> val]) {
				seen[cur -> right -> val] = true;
				q.push(cur -> right);
			}
			// push parent also
			if(parent[cur] && !seen[parent[cur] -> val]) {
				seen[parent[cur] -> val] = true;
				q.push(parent[cur])
			}
		}
	}
}
```

1. [All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)

### M-1.

```cpp
class Solution {
public:
    vector<int>res;
    unordered_map<TreeNode*, TreeNode*> parent;
    void dfs(TreeNode* root, TreeNode* p){
        if(!root) return;
        parent[root] = p;
        if(root->left) dfs(root->left, root);
        if(root->right) dfs(root->right, root);
    }
    void levelorder(TreeNode* target, int k){
        queue<TreeNode*>q;
        q.push(target);
        vector<bool>seen(501);
        seen[target->val] = 1;

        while(!q.empty() && k--){
            int currSize = q.size();
            for(int i=0; i<currSize; ++i){
                TreeNode* cur = q.front();
                q.pop();
                if(cur->left && !(seen[cur->left->val])){
                    seen[cur->left->val] = 1;
                    q.push(cur->left);
                }
                if(cur->right && !(seen[cur->right->val])){
                    seen[cur->right->val] = 1;
                    q.push(cur->right);
                }
                if(parent[cur] && !(seen[parent[cur]->val])){
                    seen[parent[cur]->val] = 1;
                    q.push(parent[cur]);
                }
            }
        }
        while(!q.empty()){
            int t = q.front()->val;
            q.pop();
            res.push_back(t);
        }
    }
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
        if(!root) return res;
        dfs(root,NULL);
        levelorder(target,k);
        return res;

    }
};
```
