## Binary Tree Introduction

**Binary Tree** : Binary Tree is defined as a tree data structure where each node has at most 2 children. Since each element in a binary tree can have only 2 children, we typically name them the left and right child.

**TreeNode Data Structure && Implement Binary Tree**

```cpp
// create TreeNode data structure
class TreeNode {
public:

    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int val) {
        this -> val = val;
        left = nullptr;
        right = nullptr;
    }

    TreeNode(int val, TreeNode* left, TreeNode* right) {
        this -> val = val;
        this -> left = left;
        this -> right = right;
    }
};
TreeNode* implemetBT() {
    // user input for current node value
    int val; cin >> val;

    // if value is -1 then no more child for current tree node
    if(val == -1) return nullptr;

    // create new node
    TreeNode* node = new TreeNode(val);

    node -> left = implemetBT();
    node -> right = implemetBT();

    return node;
}

int main() {
    TreeNode* root = implemetBT();
    return 0;
}
```

### Traversal Techniques

1. **Inorder Traversal**

```cpp
/*
    Topic : Inorder Traversal

    Constructed Binary Tree
                      1
                    /   \
                   /     \
                  2       3
                /  \      / \
               /    \    -1  -1
              /      \
             4        5
           /  \      /  \
          /    \    /    \
    -1(null)    -1 -1    -1

    input: 1 2 4 -1 -1 5 -1 -1 3 -1 -1
    output: 4 2 5 1 3

*/

#include <bits/stdc++.h>
using namespace std;


// Write TreeNode data structure here -> see above code
// Write implemetBT function here -> see above code

void inOrderTraversal(TreeNode* root) {//TC: O(n) SC: O(n)
    // if root node is null then return
    if(!root) return;

    inOrderTraversal(root -> left);
	// Do logic here
    cout << root -> val << " ";
    inOrderTraversal(root -> right);

    return;
}


void inOrderTraversalUsingStack(TreeNode* root) {//TC: O(n) SC: O(n)
    if(!root) return;

    stack<TreeNode*> st;
    TreeNode* cur = root;

    while(cur || !st.empty()) {
        while(cur) {
            st.push(cur);
            cur = cur -> left;
        }

        cur = st.top(); st.pop();
        cout << cur -> val << " ";
        cur = cur -> right;
    }

    return;
}

//Morris Traversal
//Uses Threaded Binary Tree

-   Initialize current as root
-   While current is not null:
    -   If current does not have a left child:
        (i) Print current's data.
        (ii) Go to the right, i.e., current = current.right
    -   Else:
        (i)Make current as the right child of the rightmost node in current's left subtree.
        (ii)Go to this left child, i.e., current = current.left.


void inOrderMorrisTraversal(TreeNode* root) {//TC: O(n) SC: O(1)

    if(!root) return;

    TreeNode *cur, *pre;
    cur = root;

    while(cur) {
        if(cur -> left == nullptr) {
            cout << cur -> val << " ";
            cur = cur -> right;
        }else {
          //go to right most in LST, Finding inorder predecessor
            pre = cur -> left;
            while(pre -> right != nullptr && pre -> right != cur) {
                pre = pre -> right;
            }

            if(pre -> right == nullptr) {
                pre -> right = cur;//add Thread
                cur = cur -> left;
            }else {
              //already traversed, remove th thread(link)
                pre -> right = nullptr;
                cout << cur -> val << " ";
                cur = cur -> right;
            }
        }
    }
    return;
}


int main() {
    // Call here implemetBT() -> function implemented above
    TreeNode* root = implemetBT();
    // inOrderTraversal(root);                        // Using recursion
    // inOrderTraversalUsingStack(root);              // Using stack
    inOrderMorrisTraversal(root);                     // Using morris traversal
    return 0;
}
```

2. **Preorder Traversal**

```cpp
/*
    Topic : Preorder Traversal

    Constructed binary tree is
                      1
                    /   \
                   /     \
                  2       3
                /  \      / \
               /    \    -1  -1
              /      \
             4        5
           /  \      /  \
          /    \    /    \
    -1(null)    -1 -1    -1

    input : 1 2 4 -1 -1 5 -1 -1 3 -1 -1
    output : 1 2 4 5 3

*/

#include <bits/stdc++.h>
using namespace std;


// write TreeNode data structure here -> see above code
// write implemetBT function here -> see above code

void preOrderTraversal(TreeNode* root) {
    // if root node is null then return
    if(!root) return;

	// Do logic here
    cout << root -> val << " ";
    preOrderTraversal(root -> left);
    preOrderTraversal(root -> right);

    return;
}


void preOrderTraversalUsingStack(TreeNode* root) {
    if(!root) return;

    stack<TreeNode*> st;
    TreeNode* cur = root;

    while(cur || !st.empty()) {
        while(cur) {
            cout << cur -> val << " ";
            st.push(cur);
            cur = cur -> left;
        }

        cur = st.top(); st.pop();
        cur = cur -> right;
    }
}


void preOrderMorrisTraversal(TreeNode* root) {
    if(!root) return;

    TreeNode *cur, *pre;
    cur = root;

    while(cur) {
        if(cur -> left == nullptr) {
            cout << cur -> val << " ";
            cur = cur -> right;
        }else {
            pre = cur -> left;
            while(pre -> right != nullptr && pre -> right != cur) {
                pre = pre -> right;
            }

            if(pre -> right == nullptr) {
                cout << cur -> val << " ";
                pre -> right = cur;
                cur = cur -> left;
            }else {
                pre -> right = nullptr;
                cur = cur -> right;
            }
        }
    }
    return;
}


int main() {
    // implemetBT() -> function implemented above
    TreeNode* root = implemetBT();
    // preOrderTraversal(root);
    // preOrderTraversalUsingStack(root);
    preOrderMorrisTraversal(root);
    return 0;
}
```

3. **Postorder Traversal**

```cpp
/*
    Author: rushi_mungse
    Topic : Postorder Traversal

    Constructed binary tree is
                      1
                    /   \
                   /     \
                  2       3
                /  \      / \
               /    \    -1  -1
              /      \
             4        5
           /  \      /  \
          /    \    /    \
    -1(null)    -1 -1    -1

    input :- 1 2 4 -1 -1 5 -1 -1 3 -1 -1
    output : 4 5 2 3 1

*/

#include <bits/stdc++.h>
using namespace std;


// write TreeNode data structure here -> see above code
// write implemetBT function here -> see above code

void postOrderTraversal(TreeNode* root) {
    // if root node is null then return
    if(!root) return;

    postOrderTraversal(root -> left);
    postOrderTraversal(root -> right);
    cout << root -> val << " ";           // main difference here

    return;
}


void postOrderTraversalUsingStack(TreeNode* root) {
    if(!root) return;

    stack<TreeNode*> st1, st2;
    st1.push(root);

    while(!st1.empty()) {
        TreeNode* top = st1.top(); st1.pop();
        st2.push(top);

        if(top -> left) st1.push(top -> left);
        if(top -> right) st1.push(top -> right);
    }

    while(!st2.empty()) {
        cout << st2.top() -> val << " ";
        st2.pop();
    }

    return;
}
```

4. **Level Order Traversal**

```cpp
/*
    Topic : Level Order Traversal

    Constructed binary tree is
                      1
                    /   \
                   /     \
                  2       3
                /  \      / \
               /    \    -1  -1
              /      \
             4        5
           /  \      /  \
          /    \    /    \
    -1(null)    -1 -1    -1

    input : 1 2 4 -1 -1 5 -1 -1 3 -1 -1
    output : 1
             2 3
             4 5
*/

#include <bits/stdc++.h>
using namespace std;


// write TreeNode data structure here -> see above code
// write implemetBT function here -> see above code

void levelOrderTraversal(TreeNode* root) {
    if(!root) return;
    queue<TreeNode*> q;
    q.push(root);

    while(!q.empty()) {
        for(int sz = q.size(); sz > 0; sz--) {
            TreeNode* front = q.front(); q.pop();
            cout << front -> val << " ";
            if(front -> left) q.push(front -> left);
            if(front -> right) q.push(front -> right);
        }
        cout << endl;
    }
}

vector<vector<int>> levels;
void levelOrderTraversalUsingRecursion(TreeNode* root, int level) {
    if(!root) return;
    if(levels.size() >= level) levels.push_back({});
    levels[level].push_back(root -> val);

    levelOrderTraversalUsingRecursion(root -> left, level + 1);
    levelOrderTraversalUsingRecursion(root -> right, level + 1);
}


int main() {
    // implemetBT -> function implemented above
    TreeNode* root = implemetBT();
    // levelOrderTraversal(root);
    levelOrderTraversalUsingRecursion(root, 0);
    for(auto &l : levels) {
        for(auto &val : l) cout << val << " ";
        cout << endl;
    }
    return 0;
}
```
