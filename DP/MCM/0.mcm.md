# Matrix Chain Multiplication

1. MCM
2. printing MCM
3. Evaluate exp to true/boolean paranthesization
4. Min/Max value of an Expr
5. Palindromic partioning
6. Scramble String
7. Egg dropping problem

#### Format/Identification

MCM => string/array + below one
[i...k...j] => [i...k] + [k+1....j]
f(i,j) => f(i,k) + f(k+1,j)

#### Template

```cpp
int solve(int arr[], int i, int j){
  //B.C
  if(i > j) return 0; // -> diff in diff ques

  for(int k=i; k<=j; ++k){
    int tempAns = solve(arr, i, k) + solve(arr, k+1,j); // -> add/sub .. diff in diff ques
    ans = f(tempAns); // -> f canbe min/max/anything...
  }
  return ans;
}
```

#### Steps

1. find i,j
2. find base case
3. find k loop scheme(move k -> i to j)
4. calculate cost through tempans
5. find ans from tempans

## Q-1.[MCM](https://www.codingninjas.com/studio/problems/matrix-chain-multiplication_975344)

```
- The matrix resulting from multiplication starting at i to any k (where i <= k < j) will have its row dimension from a[i-1] (since the row dimension of the first matrix in this range is at i-1 in the arr).
- The column dimension of the matrix resulting from multiplication up to k is a[k].
- Finally, the matrix from k+1 to j will start with row dimension a[k] and end with column dimension a[j].
- a[i-1] corresponds to the number of rows in the first matrix in the subproblem starting from i.
- a[k] is the shared dimension (number of columns in the matrix up to k, and number of rows in the matrix from k+1).
- a[j] is the number of columns in the last matrix of the subproblem ending at j.
```

-   a[i-1] = no fo rows in first matrix.
-   a[k] = no of cols in first matrix.
-   a[k+1] = no fo rows in last matrix.
-   a[j] = no of cols in last matrix.
-   arr = [a,b,c] -> first matrix = aXb, second matrix = bXc
-   Maatrix 1 = A1 = arr[i-1]\*arr[i] (since i starts from 1)

#### M-1. Recursion

```cpp
#include <bits/stdc++.h>

int helper(vector<int>& a, int i, int j){
    if(i >= j){
        return 0;
    }
    int ans = INT_MAX;
    for(int k=i; k<j; ++k){ // i <= k < j
            int tempAns = helper(a, i, k) + helper(a, k+1,j) + a[i-1]*a[k]*a[j];
        ans = min(ans, tempAns);
    }
    return ans;
}

int matrixMultiplication(vector<int> &arr, int N)
{
    // Write your code here.
    return helper(arr, 1, N-1);//i strats from 1
}
```

#### M-2 Memo

```cpp
#include <bits/stdc++.h>

int dp[401][401];
int helper(vector<int>& a, int i, int j){
    if(i >= j){
        return 0;
    }

    if(dp[i][j] != -1){
        return dp[i][j];
    }
    int ans = INT_MAX;
    for(int k=i; k<j; ++k){
        int tempAns = helper(a, i, k) + helper(a, k+1,j) + a[i-1]*a[k]*a[j];
        ans = min(ans, tempAns);
    }
    return dp[i][j] = ans;
}

int matrixMultiplication(vector<int> &arr, int N)
{
    memset(dp, -1, sizeof(dp));
    return helper(arr, 1, N-1);
}
```

Inside for loop
k=i to k=j-1 then (i,k) (k+1,j)
k=i+1 to k=j then (i,k-1) (k,j)

#### M-3 tabulation

```cpp
#include <bits/stdc++.h>
using namespace std;

int dp[401][401];

int matrixMultiplication(vector<int>& arr, int N) {
    memset(dp, 0, sizeof(dp)); // Initialize with zeros instead of -1 for correct min operation
    for (int len = 2; len < N; ++len) {
        for (int i = 1; i <= N - len; ++i) {
            int j = i + len - 1;
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {
                int tempAns = dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j];
                dp[i][j] = min(dp[i][j], tempAns);
            }
        }
    }
    return dp[1][N - 1];
}

int main() {
    vector<int> arr = {10, 20, 30, 40, 30};
    int N = arr.size();
    cout << "Minimum cost of matrix chain multiplication: " << matrixMultiplication(arr, N) << endl;
    return 0;
}
```

### [Minimum Score Triangulation of Polygon](https://leetcode.com/problems/minimum-score-triangulation-of-polygon/)

You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).

You will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.

Return the smallest possible total score that you can achieve with some triangulation of the polygon.

### Memo

```cpp
class Solution {
public:
    int dp[501][501];
    int minScoreTriangulation(vector<int>& values) {
        memset(dp,-1,sizeof(dp));
        return helper(values, 1, values.size()-1);
    }

    int helper(vector<int>& values, int i, int j){
        if(i >= j){
            return 0;
        }
        if(dp[i][j] != -1){
            return dp[i][j];
        }
        int ans = INT_MAX;
        for(int k=i; k<j; ++k){
            int temp = helper(values, i, k) + helper(values, k+1, j) + values[i-1]*values[k]*values[j];
            ans = min(ans, temp);
        }
        return dp[i][j] = ans;
    }
};
```

### Tabulation

```cpp
/*
Base Case: When len = 0 or len = 1, the subarrays represent either a single vertex or a line segment between two vertices, respectively. Neither can form a triangle.
First Valid Triangles: Starting len = 2 corresponds to subarrays containing exactly three vertices, which is the smallest number of vertices that can form a triangle.
*/
class Solution {
public:
    int minScoreTriangulation(vector<int>& values) {
        int n = values.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));

        // Iterate over all possible sub-polygons with increasing length
        for (int len = 2; len < n; ++len) {
            for (int i = 0; i <= n-len; ++i) {
                int j = i + len-1;
                dp[i][j] = INT_MAX;

                // Try all possible triangles in the sub-polygon
                for (int k = i; k < j; ++k) {
                    int temp  =dp[i][k] + dp[k+1][j] + values[i-1] * values[k] * values[j];
                    dp[i][j] = min(dp[i][j], temp);
                }
            }
        }

        // Minimum score triangulation of the entire polygon is stored at dp[0][n-1]
        return dp[1][n - 1];
    }
};
```

### [Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/)

Given an array arr of positive integers, consider all binary trees such that:

Each node has either 0 or 2 children;
The values of arr correspond to the values of each leaf in an in-order traversal of the tree.
The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.
Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.

A node is a leaf if and only if it has zero children.

#### Memo

```cpp
class Solution {
public:
    int dp[42][42];
    int mctFromLeafValues(vector<int>& arr) {
        memset(dp, -1, sizeof(dp));
        return helper(arr, 0, arr.size()-1);
    }

    int helper(vector<int>& arr, int i, int j) {
        if (i >= j)
            return 0;

        if(dp[i][j] != -1){
            return dp[i][j];
        }

        int res = INT_MAX;
        for (int k = i; k < j; ++k) {
            int left_max = *max_element(arr.begin() + i, arr.begin() + k + 1);
            int right_max = *max_element(arr.begin() + k + 1, arr.begin() + j + 1);
            int cost = left_max * right_max;
            res = min(res, cost + helper(arr, i, k) + helper(arr, k + 1, j));
        }
        return dp[i][j] = res;
    }
};
```

#### Tabulation

```cpp
class Solution {
public:
    int dp[42][42];
    int mctFromLeafValues(vector<int>& arr) {

        int n = arr.size();
        for(int l=1; l<n; ++l){
            for(int i=0; i<n-l;++i){
                int j = i+l;
                dp[i][j] = INT_MAX;
                for(int k=i; k<j; ++k){
                    int left_max = *max_element(arr.begin() + i, arr.begin() + k + 1);
                    int right_max = *max_element(arr.begin() + k + 1, arr.begin() + j + 1);
                    dp[i][j] = min(dp[i][j], dp[i][k] + left_max*right_max + dp[k+1][j]);
                }
            }
        }
        return dp[0][n-1];
    }
};
```

### [Burst Baloons](https://leetcode.com/problems/burst-balloons/)

You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.

If you burst the ith balloon, you will get nums[i - 1] _ nums[i] _ nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.

Return the maximum coins you can collect by bursting the balloons wisely.

```cpp
class Solution {
public:
//dp[i][j] in here means, the maximum coins we get after we burst all the balloons between i and j in the original array.
//dp[0][0] means we only burst first baloon in orig array
//dp[1][1] means we only burst first baloon in orig array
//we want to find out dp[0][ arr.length - 1 ], which is the maximum value we can get when we burst all the balloon between [0 , length -1]
    int dp[501][501];
    int maxCoins(vector<int>& nums) {
        // preprocessing: remove all zeros, insert 1 into the begin and the end
        vector<int> cleaned = {1};
        for (auto &num : nums)
            if (num) cleaned.push_back(num);
        cleaned.push_back(1);

        int n = cleaned.size()-2;
        memset(dp, -1, sizeof(dp));
        return helper(1, n, cleaned);
    }

    int helper(int i, int j, vector<int>& nums) {
        if (i > j) return 0;
        if(i == j){    // Only one element exists
            dp[i][j] = nums[i-1]*nums[i]*nums[i+1];
        }

        if (dp[i][j] != -1) return dp[i][j];

        for (int k = i; k <= j; k++) {
            int subRes =  nums[i - 1] * nums[k] * nums[j + 1] + helper(i, k - 1, nums) + helper(k + 1, j, nums);
            dp[i][j] = max(dp[i][j],subRes);
        }

        return dp[i][j] ;
    }
};
```
