[Bungeon Game](https://leetcode.com/problems/dungeon-game/)

## Recursion

```cpp
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& g) {
        int m = g.size(), n = g[0].size();
        return  helper(g, m, n, 0, 0);

    }
    int helper(vector<vector<int>>& g, int m, int n, int i, int j){
        if(i>=m || j>=n){
            return 1000000;
        }
        if(i == m-1 && j == n-1){
            return max(1, -g[m-1][n-1]+1);// Minimum health required at the bottom-right cell
        }
        int right =  max(1, helper(g,m,n,i,j+1)-g[i][j]);
        int down = max(1, helper(g,m,n,i+1,j)-g[i][j]);
        return min(right, down);
    }
};
```

## Memoization

```cpp
class Solution {
public:
    int dp[201][201];
    int calculateMinimumHP(vector<vector<int>>& g) {
        memset(dp, -1, sizeof(dp));
        int m = g.size(), n = g[0].size();
        return  helper(g, m, n, 0, 0);

    }
    int helper(vector<vector<int>>& g, int m, int n, int i, int j){
        if(i>=m || j>=n){
            return 1000000;
        }
        if(i == m-1 && j == n-1){
            return max(1, -g[m-1][n-1]+1);// Minimum health required at the bottom-right cell
        }
        if(dp[i][j] != -1){
            return dp[i][j];
        }
        int right =  max(1, helper(g,m,n,i,j+1)-g[i][j]);
        int down = max(1, helper(g,m,n,i+1,j)-g[i][j]);
        return dp[i][j] = min(right, down);
    }
};
```

## Tabulation

```cpp
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& g) {
        int m = g.size(), n = g[0].size();
        int dp[201][201];
        for (int i = m - 1; i >= 0; --i) {
            for (int j = n - 1; j >= 0; --j) {
                if (i == m - 1 && j == n - 1) {
                    dp[i][j] = max(1,  - g[i][j]+1); // Minimum health required at the bottom-right cell
                } else {
                    int right = (j == n - 1) ? 1000000 : max(1, dp[i][j + 1] - g[i][j]);
                    int down = (i == m - 1) ? 1000000 : max(1, dp[i + 1][j] - g[i][j]);
                    dp[i][j] = min(right, down);
                }
            }
        }
        return dp[0][0];
    }
};
```
