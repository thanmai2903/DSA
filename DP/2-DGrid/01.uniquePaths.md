[Unique Paths](https://leetcode.com/problems/unique-paths/)

## M-1. Recursion

-   start from top left (0,0)
-   if reaches to (m-1, n-1) return 1
-   pass this 1 from tail to head to get ans

TIme/space -> O(2^(m+n))/O(m+n)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        return helper(m,n,0,0);

    }
    int helper(int m, int n, int i, int j){
        if(i >= m || j>=n){
            return 0;
        }
        if(i == m-1 && j == n-1){
            return 1;
        }
        return helper(m,n,i+1,j) + helper(m,n,i,j+1);
    }
};
```

## M-2. Memoization

Time/Space -> O(mn)/O(mn)

```cpp
class Solution {
public:
    int dp[101][101];
    int uniquePaths(int m, int n) {
        memset(dp, -1, sizeof(dp));
        return helper(m,n,0,0);

    }
    int helper(int m, int n, int i, int j){
        if(i >= m || j>=n){
            return 0;
        }
        if(i == m-1 && j == n-1){
            return 1;
        }
        if(dp[i][j] != -1){
            return dp[i][j];
        }
        return dp[i][j] = helper(m,n,i+1,j) + helper(m,n,i,j+1);
    }
};
```

## M-3. tabulation

Time/Space -> O(mn)/O(mn)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        // Base case for dp
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < n; ++i) dp[0][i] = 1;
        for (int i = 0; i < m; ++i) dp[i][0] = 1;

        // Recursive calculation
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        // Final answer
        return dp[m-1][n-1];
    }
};
```

## M-4 Space Optimization

In the above solution, we can observe that to compute the dp matrix, we are only ever using the cells from previous row and the current row. So, we don't really need to maintain the entire m x n matrix of dp. We can optimize the space usage by only keeping the current and previous rows.

A common way in dp problems to optimize space from 2d dp is just to convert the dp matrix from m x n grid to 2 x n grid denoting the values for current and previous row. We can just overwrite the previous row and use the current row as the previous row for next iteration. We can simply alternate between these rows using the & (AND) operator as can be seen below -
Time/Space -> O(mn)/O(n)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(2, vector<int>(n,1));
        for(int i = 1; i < m; i++)
            for(int j = 1; j < n; j++)
                dp[i & 1][j] = dp[(i-1) & 1][j] + dp[i & 1][j-1];   // <- &  used to alternate between rows
        return dp[(m-1) & 1][n-1];
    }
};
```

Or still better yet, in this case, you can use a single vector as well. We are only accessing same column from previous row which can be given by dp[j] and previous column of current row which can be given by dp[j-1]

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n, 1);
        for(int i = 1; i < m; i++)
            for(int j = 1; j < n; j++)
                dp[j] += dp[j-1];
        return dp[n-1];
    }
};
```

## M-5. math

-   We start at (0, 0) cell and move to (m-1, n-1) cell.
-   We need to make m-1 down-moves and n-1 right-moves to reach the destination cell.
-   Thus, we need to perform a total number of m+n-2 moves.
-   At each cell along the path, we can choose either the right-move or down-move and we need to find the number of unique combinations of these choices (which eventually leads to unique paths).
-   This is nothing but calculating the number of different ways to choose m-1 down-moves and n-1 right-moves from a total of m+n-2 moves. Mathematically, this can be represented as -
    ![i](https://assets.leetcode.com/users/images/8b8a877c-f29f-46a9-b541-149ae4ee3468_1637114902.8508475.png)

Time/Space -> O(min(m,n))/O(1)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        long ans = 1;
        for(int i = m+n-2, j = 1; i >= max(m, n); i--, j++)
            ans = (ans * i) / j;
        return ans;
    }
};
```
