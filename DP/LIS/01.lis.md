[Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)

## M-1. Naive Way

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int>lis(n);
        lis[0] = 1;
        for(int i=1; i<n; ++i){
            lis[i] = 1;
            for(int j=0; j<i; ++j){
                if(nums[i] > nums[j]){//means increasing
                     lis[i] = max(lis[i], lis[j] + 1);
                }
            }
        }
        return *max_element(lis.begin(), lis.end());
    }
};
```

**Another Way**

```cpp
int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> lis(n, 1); // Initialize LIS array with 1 as the minimum length of LIS is 1
        int max_length = 1; // Initialize the maximum length of LIS

        for(int i = 1; i < n; ++i) {
            for(int j = 0; j < i; ++j) {
                if(nums[i] > nums[j]) {
                    lis[i] = max(lis[i], lis[j] + 1); // Update LIS at position i
                }
            }
            max_length = max(max_length, lis[i]); // Update max_length
        }

        return max_length;
    }
```

This solution is not efficient as it has a time complexity of O(N^2). The
problem can be solved in O(NlogN) time using binary search.

## M-2. Binary Search

```cpp

class Solution {
public:
    int ceilIdx(vector<int>& nums, int l, int h, int x){
        int ans = -1;
        while(l <= h){
            int mid = l + (h-l)/2;
            if(nums[mid] >= x) {
                ans = mid;
                h = mid - 1;
            }
            else l = mid + 1;
        }
        return ans;
    }

    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0; // Edge case: if nums is empty, LIS length is 0
        vector<int> tail(n);
        tail[0] = nums[0];
        int len = 1;
        for(int i = 1; i < n; ++i){
            if(nums[i] > tail[len-1]){
                tail[len] = nums[i];
                len++;
            } else {
                int x = ceilIdx(tail, 0, len - 1, nums[i]);
                tail[x] = nums[i];
            }
        }
        return len;
    }
};
```
