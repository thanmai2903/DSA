[Unique BST](https://leetcode.com/problems/unique-binary-search-trees/description/)

## Solution - I (Brute-Force) [TLE]

-   To form structurally unique BST consisting of n nodes, we can start by taking any of the node 1...n as the root node. Let the chosen root node be i. Then, we have a BST where the root node is i, the left child consist of all nodes from 1...i-1 (since left sub-tree must have only less than root's value) and right child consist of all nodes from i+1...n.

-   Now, we need to realize that the number of structurally unique BST formable with nodes having value i+1...n is equal to the number of structurally unique BST formable with nodes having value i+1-i...n-i = 1...n-i.
-   Why? Because we only need to find BST which are structurally unique irrespective of their values and we can form an equal number of them with nodes from 1...n or 2...n+1 or n...2n-1 and so on. So, the number only depends on number of nodes using which BST is to be formed.
-   Now, when we choose i as root node, we will have nodes from 1...i-1 (i-1 nodes in total) in left sub-tree and nodes from i+1...n (n-i nodes in total) in the right side. We can then form numTrees(i-1) BSTs for left sub-tree and numTrees(n-i) BSTs for the right sub-tree. The total number of structurally unique BSTs formed having root i will be equal to product of these two, i.e, numTrees(i-1) \* numTrees(n-i).
-   The same can be followed recursively till we reach base case - numTrees(0) = numTrees(1) = 1 because we can form only a single empty BST and single node BST in these cases respectively.

```cpp
TC/SC -> 3^N/N
class Solution {
public:
    int numTrees(int n) {
        if(n <= 1) return 1;
        int ans = 0;
        for(int i = 1; i <= n; i++)
            ans += numTrees(i-1) * numTrees(n-i);
        return ans;
    }
};
```

## Memoization

```cpp
TC/SC -> N^2/N
class Solution {
public:
    int dp[20]{};
    int numTrees(int n) {
        if(n <= 1) return 1;
        if(dp[n]) return dp[n];
        for(int i = 1; i <= n; i++)
            dp[n] += numTrees(i-1) * numTrees(n-i);
        return dp[n];
    }
};
```

## Tabulation

-   We have base conditions of dp[0] = dp[1] = 1.
-   Then we calculate result for each number of nodes i from 2...n one after another.
-   For i nodes. we can consider each of the node j from 1...i as the root node of BST.
-   Considering the jth node as the root node in BST having total of i nodes, the final result is summation of dp[j-1] \* dp[i-j], for all j from 1...i. (Comparing to above solution dp[j-1] = numTrees(j-1) and dp[i-j]=numTrees(i-j))

```cpp
TC/SC -> N^2/N
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0]*(n+1)
        dp[0], dp[1] = 1, 1
        for i in range(2, n+1):
            for j in range(1, i+1):
                dp[i] += dp[j-1] * dp[i-j]
        return dp[n]
```

## Catalan Number

![i](https://assets.leetcode.com/users/images/426d7a29-90f5-4316-8125-9eabbe88ebc9_1636339303.3556454.png)

```cpp
TC/Sc -> N/1
class Solution {
public:
    long ncr(int n, int r) {
        long ans = 1;
        for(int i = 0; i < r; i++) {
            ans *= n-i;
            ans /= i+1;
        }
        return ans;
    }
    int numTrees(int n) {
        return ncr(2*n, n) / (n + 1);
    }
};
```
