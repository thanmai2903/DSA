[Guess Number Higher or Lower II](https://leetcode.com/problems/guess-number-higher-or-lower-ii/)

**State:** dp(i, j)= minimum money required to guess the correct number from range 1 to n

For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.

**Recurrence:** dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)

why MAX(dp(1, i-1), dp(i+1, n) ). Again we are not playing the game rather we are planning ahead. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).

**Base case:**
dp(i,j) = 0 if i >= j

## Recursion -> TLE

```cpp
class Solution {
public:
    int getMoneyAmount(int n) {

        return helper(1, n);
    }

    int helper(int i, int j){
        if(i >= j){
            return 0;
        }

        int res = INT_MAX;

        for(int s=i; s<=j; ++s){
            int temp = s + max(helper(i, s-1), helper(s+1, j));
            res = min(res, temp);
        }
        return res;
    }
};
```

## Memoization

```cpp
class Solution {
public:
    int dp[201][201];
    int getMoneyAmount(int n) {

        memset(dp, 0, sizeof(dp));
        return helper(1, n);
    }

    int helper(int i, int j){
        if(i >= j){
            return 0;
        }
        if(dp[i][j] != 0){
            return dp[i][j];
        }

        int res = INT_MAX;

        for(int s=i; s<=j; ++s){
            int temp = s + max(helper(i, s-1), helper(s+1, j));
            res = min(res, temp);
        }
        return dp[i][j] = res;
    }
};
```
