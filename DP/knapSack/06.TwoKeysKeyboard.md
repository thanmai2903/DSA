[2 Keys Keyboard](https://leetcode.com/problems/2-keys-keyboard/)

This problem is similar to 0/1 knapsack. In Knapsack we have 2 options - to choose or not to choose. Here, we similarly have 2 options at each step - either we copy current A's those are printed on screen or add number of A's that are already copied in the clipboard to the A's printed on screen.

Here,
A_onscreen = number of A's currently/ already printed on the screen
A_clipboard = number of A's currently copied to the clipboard
Also, at each step, we have 2 options -

1. COPY: it makes #A on the clipboard = #A on the screen
2. PASTE: it makes #A on the screen = #A on the screen + #A on the clipboard

## Memoization

```cpp

class Solution {
public:
    int dp[1001][1001]; //for memoization

    int solve(int A_clipboard, int A_onscreen, int n){
        // number of A's printed on the screen should not exceed n. So return a very large number so that it won't be counted in the answer (because we are calculating minimum).
        if(A_onscreen > n) return 100000000;

        if(A_onscreen == n) return 0;
		// We got what we wanted(n A's printed on screen). No more operations required. Return 0.

        // return if already computed
        if(dp[A_clipboard][A_onscreen] != -1) return dp[A_clipboard][A_onscreen];

        // if #A in clipboard = 0, we don't want to paste 0 number of A's. Only coping can be done
        if(A_clipboard == 0) return 1 + solve(A_onscreen, A_onscreen, n);

        // if #A in clipboard = #A on the screen, we don't want to unnecessarily copy the same #A's again. Only pasting can be done
        if(A_clipboard == A_onscreen) return 1 + solve(A_onscreen, A_onscreen + A_clipboard, n);

        // if copying and pasting both are possible, do both (similar to Knapsack) and then choose the minimum of them
        int copy = solve(A_onscreen, A_onscreen, n);
        int paste = solve(A_clipboard, A_onscreen + A_clipboard, n);
        return dp[A_clipboard][A_onscreen] = 1 + min(copy, paste);
    }

    int minSteps(int n) {
        memset(dp, -1, sizeof(dp));
        if(n == 1) return 0;

        // In the beginning we have 1 A printed on the screen and 0 A's in the clipboard.
        // So, the only option we have is to copy the current character that is present on the screen.
        // This is because, pasting 0 number of A's will only increase the total number of operations and still accomplish nothing.
        // Hence, we copy the only A printed on the screen and add 1 to the answer. This makes A_clipboard = 1
        return 1 + solve(1, 1, n);
    }
};
```
