# Maximum Sum Subarray in a 2D Array

### Brute Force Approach

The brute force approach involves checking all possible subarrays and calculating their sums. This method has a time complexity of
ùëÇ(ùëõ^6) which is impractical for large arrays.

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int maxSumSubarray2D(vector<vector<int>>& matrix) {
    int n = matrix.size();
    if (n == 0) return 0;
    int m = matrix[0].size();

    int maxSum = INT_MIN;

    for (int startRow = 0; startRow < n; ++startRow) {
        for (int startCol = 0; startCol < m; ++startCol) {
            for (int endRow = startRow; endRow < n; ++endRow) {
                for (int endCol = startCol; endCol < m; ++endCol) {
                    int currentSum = 0;
                    for (int i = startRow; i <= endRow; ++i) {
                        for (int j = startCol; j <= endCol; ++j) {
                            currentSum += matrix[i][j];
                        }
                    }
                    maxSum = max(maxSum, currentSum);
                }
            }
        }
    }

    return maxSum;
}

int main() {
    vector<vector<int>> matrix = {
        {1, -2, -1, 0},
        {-3, 4, 2, -1},
        {2, -1, 5, -3},
        {1, 2, -1, -4}
    };
    cout << "Maximum Sum: " << maxSumSubarray2D(matrix) << endl;
    return 0;
}
```

## Way-2

**Intuition**

Finding the maximum sum subarray in a 2D array involves extending Kadane's Algorithm to two dimensions. The main idea is to treat each pair of columns as boundaries and reduce the 2D problem to multiple 1D problems by collapsing the columns between these boundaries into a temporary 1D array. Then, we apply Kadane's Algorithm to this temporary array to find the maximum sum for that particular set of columns.

**Algorithm**

1. Initialize Variables:

-   max_sum to store the global maximum sum.
-   temp array to store the sum of elements between two columns for each row.

2. Iterate Over Column Boundaries:

-   For each pair of columns (left, right), initialize the temp array to zero.
-   For each row, sum the elements between the left and right columns into temp.

3. Apply Kadane's Algorithm:

-   Use Kadane's Algorithm on the temp array to find the maximum sum subarray for the current column boundaries.
-   Update max_sum if the current maximum sum is greater.

4. Return max_sum:

-   After evaluating all column pairs, max_sum will hold the maximum sum of any subarray in the 2D array.

```cpp
#include <iostream>
#include <vector>
#include <climits>

int kadane(const std::vector<int>& arr) {
    int max_current = arr[0];
    int max_global = arr[0];

    for (size_t i = 1; i < arr.size(); ++i) {
        max_current = std::max(arr[i], max_current + arr[i]);
        if (max_current > max_global) {
            max_global = max_current;
        }
    }

    return max_global;
}

int max_sum_2d(const std::vector<std::vector<int>>& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    int max_sum = INT_MIN;

    for (int left = 0; left < cols; ++left) {
        std::vector<int> temp(rows, 0);
        for (int right = left; right < cols; ++right) {
            for (int i = 0; i < rows; ++i) {
                temp[i] += matrix[i][right];
            }
            int current_sum = kadane(temp);
            max_sum = std::max(max_sum, current_sum);
        }
    }

    return max_sum;
}

int main() {
    std::vector<std::vector<int>> matrix = {
        {1, 2, -1, -4, -20},
        {-8, -3, 4, 2, 1},
        {3, 8, 10, 1, 3},
        {-4, -1, 1, 7, -6}
    };
    std::cout << "Maximum Sum Subarray in 2D Array: " << max_sum_2d(matrix) << std::endl;
    return 0;
}
```

**DryRun**

```diff
 1  2 -1 -4 -20
-8 -3  4  2   1
 3  8 10  1   3
-4 -1  1  7  -6
```

Column Boundaries (left = 0, right = 0):

temp = [1, -8, 3, -4]
Kadane's Algorithm: Max sum = 3
Column Boundaries (left = 0, right = 1):

temp = [3, -11, 11, -5]
Kadane's Algorithm: Max sum = 11
Continue evaluating all pairs of columns (left, right) and updating max_sum.

Final result: Maximum sum = 29 (subarray from matrix[1][2] to matrix[3][3]).
