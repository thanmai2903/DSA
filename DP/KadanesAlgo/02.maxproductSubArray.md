[Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)

## Way 1

-   traverse arrays from both sides and apply kadanes algo

Ques : Why do we have a need to traverse from right to left ??
Ans : lets take an example
arr {-8,5,3,1,6}

// By traversing left to right we have an answer maxi1.
maxi1 = -720 , which is clearly not the max prod value.
-> The whole concept lies in this statement - As we can see that there is only 1 negative no. ( if we consider that no. then the final answer can never be positive ), therefore to avoid this situation we also traverse from right to left to get the final maximum prod.

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int maxi = INT_MIN;
        int prod=1;

        for(int i=0;i<nums.size();i++)
        {
          prod*=nums[i];
          maxi=max(prod,maxi);
          if(prod==0)
           prod=1;
        }
        prod=1;
        for(int i=nums.size()-1;i>=0;i--)
        {
          prod*=nums[i];

          maxi=max(prod,maxi);
          if(prod==0)
           prod=1;
        }
        return maxi;
    }
};
```

## Way-2

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int mx_prod = INT_MIN;
        int curr_prod = 1;
        for(auto& e: nums){
            curr_prod *= e;
            mx_prod = max(mx_prod, curr_prod);
            if(curr_prod == 0){
                curr_prod = 1;
            }
        }
        reverse(nums.begin(), nums.end());
        curr_prod = 1;
        for(auto& e: nums){
            curr_prod *= e;
            mx_prod = max(mx_prod, curr_prod);
            if(curr_prod == 0){
                curr_prod = 1;
            }
        }
        return mx_prod;
    }
};
```

## Way-3

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size(),res=nums[0];
        //calculate prefix and suffix product and res will be max of those two
        int l=0, r=0;
        for(int i=0; i<n; ++i){
            l = (l ? l : 1)*nums[i];
            r = (r ? r: 1)*nums[n-1-i];
            res = max(res,max(l,r));
        }
        return res;
    }
};
```
