[Maximum Subarray Sum with One Deletion](https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/description/)

## Dp -> constant space

````cpp
    int maximumSum(vector<int>& arr) {
        int size = arr.size();
        if ( size == 1 ) return arr[ 0 ];

		// dropped record the maximum sum ended at current index with one number being dropped
        int dropped = max( arr[ 0 ], arr[ 1 ] );
        // not dropped must take arr[ 1 ] at index = 1
        int notDropped = max( arr[ 0 ] + arr[ 1 ], arr[ 1 ] );
        int ans = max( dropped, notDropped );

        for ( int i = 2; i < size; i++ ) {
            dropped = max( notDropped, arr[ i ] + dropped );
            notDropped = max( notDropped + arr[ i ], arr[ i ] );
            ans = max( ans, max( dropped, notDropped ) );
        }
        return ans;
    }
	```

## Method-2
**INTUITION**
Problems related to largest contiguous sub-array sum should be visualised as a modified implementation of Kadane's algorithm.

**APPROACH**
We know that the largest contiguous sub-array sum can be easily computed using Kadane's Algorithm. Given problem is a modified version of it, with at most 1 deletion. So we will break the problem into three possible cases:

**Case 1 :** No deletion | Maximum contiguous sub-array sum
If we do not consider any deletion whatsoever, we can use Kadane's Algorithm to compute our answer (till here).

**Case 2 :** No deletion | At least one element in sub-array
It might be possible that Kadane's Algorithm gives answer as zero (if not even a single element is positive). In that case, we calculate the least negative element (or the max element in the array) to update our answer (till here).

**Case 3 :** One deletion | Checking by deleting a negative element
This is the major case.
For any negative element at index 'i' in the array, let:
Max prefix sum (max contiguous sub-array sum ending at i-1) be p
Max suffix sum (max contiguous sub-array sum beginning from i+1) be s
Then after deleting the negative element, the sum we get would be (p+s).
So we can update our answer to be the maximum we get from all iterations and the two above cases.

**CODE**
```cpp
class Solution {
public:
    int kadane(vector<int> a, int n) {

        int maxeh=0, maxtn=0;
        for (int i=0; i<n; i++) {
            maxeh=maxeh+a[i];
            if (maxeh<0) maxeh=0;
            maxtn=max(maxtn,maxeh);
        }
        return maxtn;
    }

    int maxel (vector<int> a, int n) {

        if (n==1) return a[0];
        int maxx=a[0];
        for (int i=0; i<n; i++) {
            if (a[i]>maxx) maxx=a[i];
        }
        return maxx;
    }

    int maximumSum(vector<int>& a) {

        int n=a.size();

        if (n==0) return 0;
        if (n==1) return a[0];

        vector<int> maxehl(n,0);
        maxehl[0]=max(a[0],0);

        for (int i=1; i<n; i++) {
            maxehl[i]=maxehl[i-1]+a[i];
            if (maxehl[i]<0) maxehl[i]=0;
        }

        vector<int> maxehr(n,0);
        maxehr[n-1]=max(a[n-1],0);

        for (int i=n-2; i>=0; i--) {
            maxehr[i]=maxehr[i+1]+a[i];
            if (maxehr[i]<0) maxehr[i]=0;
        }

        // case 1 : sum of largest contiguous sub-array
        // no deletion
        int ans=kadane(a,n);

        // case 2 : least negative no. in case of all negative
        // no deletion
        if (ans==0) {
            ans=maxel(a,n);
        }

        // case 3 : deleting one negative element
        // one deletion
        for (int i=1; i<n-1; i++) {
            if (a[i]<0) {
                ans=max(ans, maxehl[i-1]+maxehr[i+1]  );
            }
        }
        if (ans==0) return maxel(a,n);
        return ans;
    }
};
````
